#include <Arduino.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <Ticker.h> 

// --- 0. HARDWARE DEFINITIONS ---
// PINES DE BOTONES (Se usa INPUT_PULLUP)
#define MODE_BUTTON_PIN 13 
#define SET_BUTTON_PIN 27  

// --- 1. CONFIGURACIÓN LCD I2C ---
LiquidCrystal_I2C lcd(0x27, 16, 2);

// --- 2. MÁQUINA DE ESTADOS DEL CRONÓMETRO ---
enum CronoSubEstados {
  CRONO_PARADO,    
  CRONO_CORRIENDO, 
  CRONO_PAUSADO    
};

CronoSubEstados cronoEstado = CRONO_PARADO;

// --- 3. VARIABLES DE CRONÓMETRO ---
Ticker cronometroTicker;
volatile unsigned long contadorCrono = 0; 

unsigned long lastButtonPress = 0; 
String lastPrintedTime = "00:00:00"; // Guarda el último tiempo impreso

// --- 4. PROTOTIPOS DE FUNCIONES ---
void incrementarCrono();
String obtenerTiempoFormateado();
void iniciarCronometro();
void detenerCronometro();
void reiniciarCronometro();
void actualizarLCDEstado(bool forzarCompleto = false); // Renombrada y modificada
void actualizarLCDTiempo(); // Nueva función solo para el tiempo
void manejarBotonesHardware();

// ===============================================
// === 5. FUNCIONES DE LÓGICA DEL CRONÓMETRO ===
// ===============================================

// Función llamada por el Ticker cada 0.01 segundo (10 milisegundos)
void incrementarCrono() {
    if (cronoEstado == CRONO_CORRIENDO) { 
        contadorCrono++;
    }
}

void iniciarCronometro() {
    cronometroTicker.attach(0.01, incrementarCrono); 
}

void detenerCronometro() {
    cronometroTicker.detach();
}

void reiniciarCronometro() {
    detenerCronometro();          
    contadorCrono = 0;            
    cronoEstado = CRONO_PARADO;   
    actualizarLCDEstado(true); // Forzar actualización completa al resetear
}

// Convierte el contador de centésimas a formato MM:SS:DSDS
String obtenerTiempoFormateado() {
    unsigned long totalCentisegundos = contadorCrono;
    
    int cs = totalCentisegundos % 100;
    unsigned long totalSegundos = totalCentisegundos / 100;
    int s = totalSegundos % 60;
    int m = totalSegundos / 60; 
    
    char buffer[10]; // MM:SS:CS\0
    sprintf(buffer, "%02d:%02d:%02d", m, s, cs);
    return String(buffer);
}


// ===============================================
// === 6. FUNCIÓN DE MANEJO DE HARDWARE ===
// ===============================================

void manejarBotonesHardware() {
    const unsigned long debounceDelay = 200; 
    bool setPressed = digitalRead(SET_BUTTON_PIN) == LOW;
    bool modePressed = digitalRead(MODE_BUTTON_PIN) == LOW;

    // --- Lógica de Debounce ---
    bool isButtonActive = setPressed || modePressed;
    
    if (isButtonActive) {
        if (millis() - lastButtonPress < debounceDelay) return;
        lastButtonPress = millis();
    } else {
        lastButtonPress = 0;
        return;
    }
    
    // --- Lógica de la Máquina de Estados del Cronómetro ---
    CronoSubEstados estadoAnterior = cronoEstado;
    
    // 1. Botón SET: START / PAUSE / RESUME
    if (setPressed) { 
        if (cronoEstado == CRONO_PARADO) {
            iniciarCronometro();
            cronoEstado = CRONO_CORRIENDO;
        } else if (cronoEstado == CRONO_CORRIENDO) {
            detenerCronometro(); 
            cronoEstado = CRONO_PAUSADO;
        } else if (cronoEstado == CRONO_PAUSADO) {
            iniciarCronometro(); // Reanuda
            cronoEstado = CRONO_CORRIENDO;
        }
    } 
    
    // 2. Botón MODE: RESET/FINALIZAR (Solo funciona si no está PARADO)
    else if (modePressed) { 
        if (cronoEstado != CRONO_PARADO) {
            reiniciarCronometro(); 
            return; // La función reiniciarCronometro ya actualiza la LCD completamente
        }
    }

    // Si el estado cambió (ej. de PARADO a CORRIENDO), actualizar la línea de estado
    if (cronoEstado != estadoAnterior) {
        actualizarLCDEstado(true); // Forzar actualización de ambas líneas
    }
}

// ===============================================
// === 7. FUNCIONES DE DISPLAY (LCD) OPTIMIZADAS ===
// ===============================================

// Función para actualizar SOLO el tiempo (Línea 2)
void actualizarLCDTiempo() {
    String currentTime = obtenerTiempoFormateado();
    
    // Compara el tiempo actual con el último impreso para evitar reescritura
    // Esto es vital para evitar el parpadeo en las partes que no cambian (Minutos, Segundos)
    for (int i = 0; i < currentTime.length(); i++) {
        if (currentTime[i] != lastPrintedTime[i]) {
            lcd.setCursor(i, 1);
            lcd.print(currentTime[i]);
        }
    }
    lastPrintedTime = currentTime;
}

// Función para actualizar el Estado (Línea 1) y forzar una actualización completa
void actualizarLCDEstado(bool forzarCompleto /*= false*/) {
    
    lcd.setCursor(0, 0);
    
    // Mensaje de estado
    if (cronoEstado == CRONO_PARADO) {
        lcd.print("CRONO STOPPED   "); // Rellenar con espacios para borrar lo anterior
    } else if (cronoEstado == CRONO_CORRIENDO) {
        lcd.print("CRONO RUNNING   ");
    } else { // CRONO_PAUSADO
        lcd.print("CRONO PAUSED    ");
    }
    
    // Si se forzó una actualización (cambio de estado/reset), actualizar el tiempo también
    if (forzarCompleto) {
        // La línea de tiempo completa, forzando la impresión de '00:00:00'
        lastPrintedTime = ""; 
        actualizarLCDTiempo();
    }
}


// ===============================================
// === 8. SETUP Y LOOP ===
// ===============================================

void setup() {
    Serial.begin(115200);
    Wire.begin(); 

    // Inicializar LCD (Solo se hace el clear aquí)
    lcd.init();
    lcd.backlight();
    lcd.clear(); // Limpiar la primera y única vez
    
    // Inicializar Pines de Hardware (Botones)
    pinMode(MODE_BUTTON_PIN, INPUT_PULLUP);
    pinMode(SET_BUTTON_PIN, INPUT_PULLUP);
    
    // Mensaje de inicio (Usamos la nueva función)
    actualizarLCDEstado(true); // Forzar impresión inicial de 00:00:00 y estado
    lcd.setCursor(0, 1);
    lcd.print("00:00:00");
    lcd.setCursor(0, 0);
    lcd.print("LISTO. SET=START");

    delay(2000);
    actualizarLCDEstado(true); // Mostrar estado final PARADO
}

void loop() {
    // 1. Manejar botones (Detecta pulsaciones y cambia el estado del crono)
    manejarBotonesHardware();
    
    // 2. Actualizar el tiempo SÓLO si está corriendo
    if (cronoEstado == CRONO_CORRIENDO) {
        actualizarLCDTiempo(); // ¡Solo actualiza los caracteres cambiados!
    }
    
    // Un pequeño delay (mínimo) para no sobrecargar el bus I2C
    delay(5); 
}