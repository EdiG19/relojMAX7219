#include <Arduino.h>

// --- 0. HARDWARE DEFINITIONS ---
#define SET_BUTTON_PIN 27  // BOTÓN PARA INICIAR LA MELODÍA
#define MODE_BUTTON_PIN 13 // BOTÓN PARA DETENER LA MELODÍA
#define BUZZER_PIN_SIGNAL 26 // PIN DEL BUZZER PASIVO

// --- 1. MELODÍA DE ALARMA: MARCHA IMPERIAL (Simplificada) ---
// Frecuencias de las notas (las mismas de antes)
#define NOTE_B4  494
#define NOTE_A4  440
#define NOTE_G4  392
#define NOTE_FSH4 370
#define NOTE_D5  587
#define NOTE_C5  523

int melody[] = {
  NOTE_A4, NOTE_A4, NOTE_A4, NOTE_FSH4, NOTE_C5,
  NOTE_A4, NOTE_FSH4, NOTE_C5, NOTE_A4
};

// Duraciones (cuartos, octavos, etc.)
int durations[] = {4, 4, 4, 5, 15, 4, 5, 15, 8};
int tempo = 10; 

// --- 2. VARIABLES DE ESTADO ---
enum BuzzerEstado {
    PARADO,
    SONANDO
};

BuzzerEstado estadoActual = PARADO;
unsigned long lastButtonPress = 0; 

// --- 3. PROTOTIPOS DE FUNCIONES ---
void playStarWars();
void manejarBuzzer();


// ===============================================
// === 4. FUNCIONES DE AUDIO ===
// ===============================================

// Reproduce un tono con la duración completa (Volumen Máximo)
void playToneMax(int freq, long duration) {
    // Usamos 'tone' para el Buzzer Pasivo
    tone(BUZZER_PIN_SIGNAL, freq);
    delay(duration);
    noTone(BUZZER_PIN_SIGNAL);
    // Pausa corta entre notas para diferenciar
    delay(duration / 8); 
}

// Reproduce la melodía completa de Star Wars
void playStarWars() {
    int notes = sizeof(melody) / sizeof(melody[0]);
    for (int i = 0; i < notes; i++) {
        // Si el estado cambia a PARADO mientras se reproduce, detenemos el loop
        if (estadoActual == PARADO) {
            noTone(BUZZER_PIN_SIGNAL);
            break; 
        }
        
        // Calcula la duración real de la nota
        int noteDuration = 60000 / tempo / durations[i];
        playToneMax(melody[i], noteDuration);
    }
    
    // Una vez terminada la melodía, si sigue en SONANDO, la repite
    if (estadoActual == SONANDO) {
        // Pequeña pausa antes de repetir
        delay(500); 
    }
}


// ===============================================
// === 5. MANEJO DE HARDWARE ===
// ===============================================

void manejarBuzzer() {
    const unsigned long debounceDelay = 200;
    
    bool set = digitalRead(SET_BUTTON_PIN) == LOW;   // START
    bool mode = digitalRead(MODE_BUTTON_PIN) == LOW; // STOP
    
    if (!set && !mode) {
        lastButtonPress = 0;
        return;
    }
    
    if (millis() - lastButtonPress < debounceDelay) return;
    lastButtonPress = millis();

    // --- LÓGICA DE ESTADOS ---
    
    // 1. Iniciar el sonido (SET)
    if (set && estadoActual == PARADO) {
        estadoActual = SONANDO;
        Serial.println("Estado -> SONANDO. Iniciando Star Wars...");
    } 
    
    // 2. Detener el sonido (MODE)
    else if (mode && estadoActual == SONANDO) {
        estadoActual = PARADO;
        noTone(BUZZER_PIN_SIGNAL);
        Serial.println("Estado -> PARADO. Deteniendo melodía.");
    }
}


// ===============================================
// === 6. SETUP Y LOOP ===
// ===============================================

void setup() {
    Serial.begin(115200);

    // Inicializar Pines de Hardware
    pinMode(SET_BUTTON_PIN, INPUT_PULLUP);
    pinMode(MODE_BUTTON_PIN, INPUT_PULLUP);
    pinMode(BUZZER_PIN_SIGNAL, OUTPUT);
    digitalWrite(BUZZER_PIN_SIGNAL, LOW); // Asegura que esté en silencio al inicio

    Serial.println("--- Prueba de Buzzer Aislada ---");
    Serial.println("Presiona SET (Pin 27) para Iniciar Melodía.");
    Serial.println("Presiona MODE (Pin 13) para Detener Melodía.");
}

void loop() {
    // Siempre maneja los botones
    manejarBuzzer();

    // Si el estado es SONANDO, reproduce la melodía. 
    // La función playStarWars() es bloqueante y se repite si el estado sigue SONANDO.
    if (estadoActual == SONANDO) {
        playStarWars();
    }
    
    // Si no está sonando, solo hace una pausa mínima y vuelve a chequear botones.
    else {
        delay(10);
    }
}